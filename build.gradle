buildscript {
    repositories {
        maven {
            url 'https://jitpack.io'
        }
        mavenCentral()
    }
    dependencies {
        classpath 'com.github.dexman545.Outlet:Outlet:1.3.4'//master-SNAPSHOT
    }
}

plugins {
    id 'fabric-loom' version '0.12.+'
    //id "com.github.fudge.forgedflowerloom" version "2.0.0"
    id 'io.github.juuxel.loom-quiltflower' version '1.+'
    id 'maven-publish'
    id "com.modrinth.minotaur" version "2.+"
    id 'com.matthewprenger.cursegradle' version '1.4.+'

    // To trigger musical code on project refresh and run processResources on project launch in Idea
    id "org.jetbrains.gradle.plugin.idea-ext" version "0.10"
}
apply plugin: 'dex.plugins.outlet'

import com.matthewprenger.cursegradle.CurseUploadTask
import com.modrinth.minotaur.dependencies.ModDependency
import groovy.json.JsonSlurper

repositories {
    maven {
        url 'https://api.modrinth.com/maven'
        name 'Modrinth'
    }
    maven {
        url 'https://jitpack.io'
        content {
            includeGroup "com.github.dexman545"
        }
    }
}

outlet.mcVersionRange = project.range

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(outlet.javaVersion()))
    }
}

System.out.println("Using toolchain: " + outlet.javaVersion())

archivesBaseName = project.archives_base_name
version = project.mod_version
group = project.maven_group

logger.lifecycle(outlet.latestMc())

boolean useLatestMc = true
if (useLatestMc || file('asdev.txt').exists()) {
    logger.lifecycle('Using latest versions')
    project.minecraft_version = outlet.latestMc()
    //project.modmenu_version = getLatestModMenu()
    project.loader_version = outlet.loaderVersion()
    project.yarn_mappings =  outlet.yarnVersion()
    project.fabric_version = outlet.fapiVersion()
    project.java = outlet.javaLanguageCompatibility()
}

outlet {
    maintainPropertiesFile = file('asdev.txt').exists()
    propertiesData = ['fabric_version': project.fabric_version,
            'minecraft_version' : project.minecraft_version,
            'yarn_mappings' : project.yarn_mappings,
            'loader_version' : project.loader_version,
            'java' : project.java]
}

loom {
    // Enable runtime only log4j, forces mod to use SLF4J for logging.
    runtimeOnlyLog4j = true
}

// Controls if optional deps. should be loaded at runtime via runClient
def useCompileOnlyDeps = false

configurations { //todo move into Outlet, change include to work differently
    optional {
        transitive = false
    }
    requiredModImpl {
        transitive = false
    }
    requiredModApi {
        transitive = false
    }
    requiredLib

    // Natural hierarchy is inverted for Gradle
    modCompileOnly.extendsFrom(optional)
    if (useCompileOnlyDeps) modRuntime.extendsFrom(optional)
    modImplementation.extendsFrom(requiredModImpl)
    implementation.extendsFrom(requiredLib)
    include.extendsFrom(requiredModApi, /*requiredModImpl,*/ requiredLib) // Disabled modImpl as fapi modules depend on other modules
    modApi.extendsFrom(requiredModApi)
}

//noinspection SpellCheckingInspection
dependencies {
    // To change the versions see the gradle.properties file
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

    // Fabric API.
    requiredModImpl "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

    // OWNER library
    requiredLib "org.aeonbits.owner:owner:1.0.12"

    // Autoswitch API
    requiredModApi 'com.github.dexman545:autoswitch-api:3.0.0'//-SNAPSHOT

    // Mod Compat ------------
    // ModMenu
    //optional "maven.modrinth:modmenu:${project.modmenu_version}"

}

/**
* Generate list of Fabric API modules based on fabric.mod.json
*/
Set<String> fapiModules() {
    def out = []
    project.sourceSets.main.resources.files.each {
        if (it.name == 'fabric.mod.json') {
            def modJson = new JsonSlurper().parse(it)
            out = modJson.depends.keySet().findAll { id ->
                (id as String).startsWith('fabric-')
            }
        }
    }
    return out
}

/*remapJar { //Disabled till loom 0.7 adds it. Planned for creating a standalone jar
    include configurations.requiredLib
}*/

processResources {
    inputs.property "version", project.version
    inputs.property "range", project.range
    inputs.property "java", project.java

    filesMatching("fabric.mod.json") {
        expand "version": project.version, "range": project.range, "java": project.java
    }

    filesMatching("autoswitch.mixins.json") {
        expand "java": project.java
    }
}

tasks.withType(JavaCompile).configureEach {
    // ensure that the encoding is set to UTF-8, no matter what the system default is
    // this fixes some edge cases with special characters not displaying correctly
    // see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
    // If Javadoc is generated, this must be specified in that task too.
    it.options.encoding = "UTF-8"

    it.options.incremental = true

    // The Minecraft launcher currently installs Java 8 for users, so your mod probably wants to target Java 8 too
    // JDK 9 introduced a new way of specifying this that will make sure no newer classes or methods are used.
    // We'll use that if it's available, but otherwise we'll use the older option.
    def targetVersion = project.java as int
    System.out.println("Using level: " + targetVersion)
    if (JavaVersion.current().isJava9Compatible()) {
        it.options.release.set(targetVersion)
    } else {
        it.sourceCompatibility = JavaVersion.toVersion(targetVersion)
        it.targetCompatibility = JavaVersion.toVersion(targetVersion)
    }
}

java {
    // Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
    // if it is present.
    // If you remove this line, sources will not be generated.
    withSourcesJar()
}

jar {
    from("LICENSE") {
        rename { "${it}_${project.archivesBaseName}" }
    }
}

// configure the maven publication
publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
        }
    }

    // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
    repositories {
        // Add repositories to publish to here.
        // Notice: This block does NOT have the same function as the block in the top level.
        // The repositories here will be used for publishing your artifact, not for
        // retrieving dependencies.
    }
}

static def getCheckedOutGitCommitHash() {
    'git rev-parse --verify --short HEAD'.execute().text.trim()
}

def uniChangelog = "This is autopublished from Github Actions. Use at your own risk. See commit history or a release " +
        "build for changes. Based on commit: ${getCheckedOutGitCommitHash()}\n\n<br />" +
        "This build may work on Minecraft versions not specified for this version. Release cadence at time of writing " +
        "(2/12/2021):\n\n<br />" +
        "1.x.x -> 1.14-1.15 | 2.x.x -> 1.16.x | 3.x.x -> 1.16.2 - 1.18.1 | 4.x.x -> 1.18.2 (22w06a) - 1.19 (22w15a) | 5.x.x -> 1.19 (22w16a) - current (and possibly beyond)\n\n<br />"

modrinth {
    token = System.getenv("MODRINTH")
    projectId = 'uSdcnlts'
    versionName = "AutoSwitch $project.version (autopublished)"
    versionNumber = project.version
    versionType = getReleaseMonicker()
    uploadFile = remapJar
    gameVersions = outlet.mcVersions()
    loaders = ["fabric"]
    changelog = uniChangelog
    dependencies = [new ModDependency("P7dR8mSH", "required")] // Creates a new required dependency on Fabric API
}

curseforge {
    if (System.getenv("CURSE")) {
        apiKey = System.getenv("CURSE")
    }

    project {
        id = '347405'
        changelog = uniChangelog
        releaseType = getReleaseMonicker()

        outlet.curseforgeMcVersions().each {
            if (it.endsWith(".0")) it = it.substring(0, it.length()-2)
            addGameVersion it
        }
        addGameVersion 'Fabric'

        changelogType = 'html'

        mainArtifact(remapJar) {
            displayName = "AutoSwitch $project.version (autopublished)"
        }

        relations {
            requiredDependency 'fabric-api'
        }

        afterEvaluate {
            uploadTask.dependsOn("remapJar")
        }
    }

    options {
        forgeGradleIntegration = false
        //debug = true // Non-upload testing
    }
}

// Only publish to Curseforge for releases
// I intend for beta and alpha builds to be Modrinth exclusives
tasks.withType(CurseUploadTask) {
    onlyIf {
        "release" == getReleaseMonicker()
    }
}

/**
 * Get latest Mod Menu version from Fabric's maven. Not keyed to MC version.
 *
 * @return mod menu version.
 */
// I got tired of having to find the right version, ok?
String getLatestModMenu() {

    // Build version list in format for url
    def versionList = "["
    boolean first = true
    for (String ver : outlet.mcVersions()) {
        if (first) {
            versionList += '%22' + ver + '%22'
            first = false
        } else {
            versionList += "," + '%22' + ver + '%22' // %22 = ", used to fix encoding issue
        }
    }
    versionList += "]"
    // End build version list format

    // Uses Modmenu's project id
    def url = "https://api.modrinth.com/api/v1/mod/mOgUt4GM/version?game_versions=${versionList}" as String
    def modMenuVersions = new groovy.json.JsonSlurper().parseText(new URL(url).text) as ArrayList

    return modMenuVersions.first().version_number
}

/**
 * Get the type of release.
 * <p>
 * Used for publishing to distribution services.
 *
 * @return build release type, such as 'alpha', 'beta', or 'release'
 */
String getReleaseMonicker() {
    if (((String) project.version).contains('alpha')) return "alpha"
    if (((String) project.version).contains('beta')) return "beta"
    return "release"
}

// Fixes fabric.mod.template's variables not being replaced with Idea's run configs.
task fixResourcesLaunch(type: Copy) {
    String name = project.name.replace(" ", "_") + ".main"

    destinationDir file("${projectDir}/out/production/${name}")
    from processResources
}

idea.project.settings {
    taskTriggers {
        afterBuild fixResourcesLaunch
    }
}

/**
 * @return old MC version from musical-code-data.properties for use in musical code
 */
String getOldMcVersion(boolean getNewMc) {
    Properties props = new Properties()
    File f = new File("${projectDir}/musical-code-data.properties")
    if (!f.exists()) f.newWriter().close()
    props.load(f.newDataInputStream())

    def currMC = props.get('currMC') as String
    def oldMC = props.get('oldMC') as String

    if (oldMC == null) props.setProperty('oldMC', "${project.minecraft_version}")
    if (currMC == null) {
        props.setProperty('currMC', "${project.minecraft_version}")
        currMC = project.minecraft_version
    }

    if (currMC != "${project.minecraft_version}") {
        props.setProperty('oldMC', currMC as String)
        props.setProperty('currMC', "${project.minecraft_version}")
    }

    props.store(f.newWriter(), null)

    if (getNewMc) return props.get('currMC') as String

    return props.get('oldMC') as String
}

// From https://stackoverflow.com/a/42691104
// Licensed under CC BY-SA 3.0
private static String runCommands(String... commands) {
    def process = new ProcessBuilder(commands).redirectErrorStream(true).start()
    process.waitFor()
    def result = ''
    process.inputStream.eachLine { result += it + '\n' }
    def errorResult = process.exitValue() == 0
    if (!errorResult) {
        throw new IllegalStateException(result)
    }
    return result
}

publish.finalizedBy(modrinth)
tasks.runClient.dependsOn(tasks.processResources)
